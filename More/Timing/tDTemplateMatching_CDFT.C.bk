/***************************************************************************
 *
 *   Copyright (C) 2009 by Willem van Straten
 *   Licensed under the Academic Free License version 2.1
 *
 ***************************************************************************/

#include "Pulsar/tDTemplateMatching_CDFT.h"
#include "Pulsar/PulsarCalibrator.h"
#include "Pulsar/PolnProfileFit.h"

#include "Pulsar/Archive.h"
#include "Pulsar/Integration.h"

extern "C" void tdfftfit_(int *nchan,int *nbins,double *shift,double *eshift,double *dDM,double *edDM,double *D_0,double *freq,int *mfit);

using namespace std;

Pulsar::tDTemplateMatching_CDFT::tDTemplateMatching_CDFT ()
{
  fs = 1;
  dmfit = 0;
}

Pulsar::tDTemplateMatching_CDFT::~tDTemplateMatching_CDFT ()
{
}

//! Set the frequency scrunch factor in preprocess
void Pulsar::tDTemplateMatching_CDFT::set_fscrunch_factor (unsigned fsfac)
{
  fs = fsfac;
}

//! Set if dm fit included
void Pulsar::tDTemplateMatching_CDFT::set_dmfit (unsigned dmsign)
{
  dmfit = dmsign;
}

//! Fequency scrunch before opertaion
void Pulsar::tDTemplateMatching_CDFT::preprocess (Archive* archive)
{
  archive->dedisperse();
  archive->fscrunch (fs);
}

void Pulsar::tDTemplateMatching_CDFT::set_standard (const Archive* archive)
{
  standard = archive;
  std_freq = standard->get_centre_frequency();
  std_bw = standard->get_bandwidth();
  std_dm = standard->get_dispersion_measure();
  std_nbin = standard->get_nbin();
  std_nchan = standard->get_nchan();
  std_nsub = standard->get_nsubint();
}

//! Set the observation from which the arrival times will be derived
void Pulsar::tDTemplateMatching_CDFT::set_observation (const Archive* archive)
{
  observation = archive;
  obs_freq = observation->get_centre_frequency();
  obs_bw = observation->get_bandwidth();
  obs_dm = observation->get_dispersion_measure();  
  obs_nbin = observation->get_nbin();
  obs_nchan = observation->get_nchan();
}

//! get the arrival times for the specified sub-integration
void Pulsar::tDTemplateMatching_CDFT::get_toas (unsigned isub,
					       std::vector<Tempo::toa>& toas)
{  
  ofstream out;
  const Integration* integration = observation->get_Integration (isub);
  const Integration* tmpl = standard->get_Integration (0);
  int mfit,nchan_s,nbin_s;
  double D,D0,Pt,obs_freq_sub[obs_nchan],offs,eoffs,dDM,edDM;
  unsigned i,j,nbin,nchan;

  //! Check if observing settings match
  if(obs_freq!=std_freq)
    {
      cout << "Central frequencies of profile and template do not match." << endl;
      exit(0);
    }
  if(obs_bw!=std_bw)
    {
      cout << "Bandwidths of profile and template do not match." << endl;
      exit(0);
    }
  if(obs_nchan!=std_nchan)
    {
      cout << "Channel numbers of profile and template do not match." << endl;
      exit(0);
    }
  if(obs_nbin!=std_nbin)
    {
      cout << "Bin numbers of profile and template do not match." << endl;
      exit(0);
    }
  if(obs_dm!=std_nbin)
    {
      cout << "DM values for preprocessing the profile and template are not the same." << endl;
      cout << "Modify the header to fix it." << endl;
      exit(0);
    }
  if(std_nsub>1)
    {
      cout << "Warning: More than one subint in the template file. Use the first for fitting." << endl;
    }

  nchan = obs_nchan;
  nbin = obs_nbin;
  D = 1.0/2.41e-4; //Dispersion constant 
  mfit = nchan+1+dmfit; //Number of parameters in fit
  Pt = integration->get_folding_period(); //Get period
  D0 = D*nbin/Pt;

  //! Get central frequency of each channel 
  for (i=0; i<obs_nchan; i++)
    obs_freq_sub[i]=integration->get_centre_frequency(i);

  //! Write profile and template to tmp files
  out.open("2Dprof.tmp", ios::out);
  for(i=0;i<nchan;i++)
    {
      vector<float>iamp=integration->get_Profile(0,i)->get_amps();
      for(j=0;j<nbin;j++)
	out.open << iamp[j] << "\n";
    }
  out.close(); 
  out.open("2Dtmpl.tmp", ios::out);
  for(i=0;i<nchan;i++)
    {
      vector<float>iamp=tmpl->get_Profile(0,i)->get_amps();
      for(j=0;j<nbin;j++)
        out.open << iamp[j] << "\n";
    }
  out.close();

  //! Get phase shift and error in unit of bin
  nchan_s=(int)nchan;
  nbin_s=(int)nbin;
  tdfftfit_(&nchan_s,&nbin_s,&offs,&eoffs,&dDM,&edDM,&D0,obs_freq_sub,&mfit);

  //! Convert unit to second
  offs=offs/nbin*Pt;
  eoffs=eoffs/nbin*Pt;

  //! Pass to shift vector (need to check)
  Estimate<double> shift = {offs, eoffs};

  //! Get TOA
  Tempo::toa TOA = get_toa (shift, integration, 0);

  toas.push_back( TOA );
}
